# -*- coding: utf-8 -*-
"""Copy of Day4_Python_for_DS

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hMLE05Z8F4si1UkYVoLNTBf5bCjnqSDQ
"""

import pandas as pd
from sklearn.preprocessing import StandardScaler
df = pd.DataFrame({'Marks': [70, 80, 90, 65, 75],
                   'Attendance': [85, 90, 95, 80, 85]})

scaler = StandardScaler()
df_scaled = df.copy()
df_scaled[["Marks", "Attendance"]] = scaler.fit_transform(df[["Marks", "Attendance"]])
print(df_scaled)

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
df_scaled[["Marks", "Attendance"]] = scaler.fit_transform(df[["Marks", "Attendance"]])
print(df_scaled)

# Assume 'Marks' column is used to determine if a student passed (e.g., >= 70)
df['Passed'] = df['Marks'] >= 70

# Now you can create dummy variables for the 'Passed' column
df_encoded = pd.get_dummies(df, columns=["Passed"], drop_first=True)
print(df_encoded)

from sklearn.preprocessing import LabelEncoder
encoder = LabelEncoder()
df["Passed"] = encoder.fit_transform(df["Passed"])
print(df)

def performance_category(marks):
    if marks >= 85:
        return "High"
    elif marks >= 70:
        return "Medium"
    else:
        return "Low"

df["Performance"] = df["Marks"].apply(performance_category)
print(df)

# Add a new 'Age' column to the DataFrame before using pd.cut
import pandas as pd
import numpy as np  # Import numpy for generating random ages

# Assuming you want to add random ages between 18 and 25
df['Age'] = np.random.randint(18, 25, df.shape[0])

df["Age_Group"] = pd.cut(df["Age"], bins=[18, 21, 24], labels=["Young", "Adult"])
print(df)

print(df.isnull().sum())

df_cleaned = df.dropna()  # Removes rows with missing values
print(df_cleaned)

df["Age"].fillna(df["Age"].mean(), inplace=True)
df["Marks"].fillna(df["Marks"].median(), inplace=True)
df["Attendance"].fillna(df["Attendance"].mean(),
inplace=True)

df["Passed"].fillna(df["Passed"].mode()[0], inplace=True)

df.ffill(inplace=True)  # Forward fill
df.bfill(inplace=True)  # Backward fill
df.drop_duplicates(inplace=True)
print(df)

